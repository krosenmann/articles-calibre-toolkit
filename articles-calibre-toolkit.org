#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+TITLE: Плагины для работы со статьями в Calibre
#+DATE: <2018-10-21 Вс>
#+AUTHOR: roman
#+EMAIL: krosenmann@gmail.com
#+LANGUAGE: ru
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 27.0.50 (Org mode 9.1.14)
#+STARTUP: showall

* Вступление
  Articles Calibre Toolkit -- набор плагинов Calibre для организации
  работы с научными статьями.
  #+CAPTION: Список плагинов
  #+tblname: plugins
  | Название плагина    | Описание                                       | Тип                 |
  |---------------------+------------------------------------------------+---------------------|
  | Scientific Metadata | Загружает метаданные по DOI статьи из CrossRef | Source              |
  | Extract DOI         | Извлекает DOI из документа                     | InterfaceActionBase |

* TODO Установка и настройка
   Плагины устанавливаются независимо, и могут быть использованы
   порозонь. Поэтому для установки достаточно скопировать интересующие
   zip-файлы в папку с плагинами Calibre, например
   =~/.config/calibre/plugins= в Ubuntu.

* TODO Как это устроено?
  Каждый плагин Calibre имеет определенную структуру и наследуется от
  некотого базового класса, в зависимости от типа (указан в
  таблице выше).
  Есть общие для всех плагинов аттрибуты, в которых указывается
  имя, описание, версия, информация об авторе и т.д.
  #+name: Информация о наборе
  #+BEGIN_SRC python :exports code
    supported_platforms = ['windows', 'osx', 'linux']
    author = 'Roman Zayrullin'
    version = (0, 0, 1)
    minimum_calibre_version = (3, 0, 0)
  #+END_SRC
  #+name: datamacro
  #+BEGIN_SRC elisp :var plinfo=plugins :var ord=1
    (let ((plugin-info
           (mapcar (lambda (x)
                     (format "class %s(%s)\n    %s"
                             (replace-regexp-in-string " " "" (car x))
                             (caddr x)
                             (format "name = '%s'\n    description = '%s'" (car x) (cadr x))))
                   plinfo)))
      (cond ((equal ord 1) (car plugin-info))
            ((equal ord 2) (cadr plugin-info))))
  #+END_SRC

  #+RESULTS: datamacro
  : class ScientificMetadata(Source)
  :     name = 'Scientific Metadata'
  :     description = 'Загружает метаданные по DOI статьи из CrossRef'

** Поиск и загрузка метаданных 
  Плагин, условно, можно разделить на 2 части:
  + Обработка и выкачивание данных из сети (с помощью библиотек
    [[https://habanero.readthedocs.io/en/latest/][habanero]] и [[https://bibtexparser.readthedocs.io/en/master/index.html][bibtexparser]])
  + Программно-интерфейсные вещи: чтение информации о публикации из
    Calibre, и запись полученной из сети информации. 

  Для плагинов метаданных в Calibre переопределяется метод ~identify~,
  в который уже передается большая часть нужной информации и все
  необходимые для загрузки интерфейсы. Все, что нужно здесь сделать:
  корректно вызвать необходимые методы и передать DOI функции загрузки
  для, непосредственно, загрузки.
  Для целостности пакавана, выясним, является ли записанный в БД
  Calibre DOI корректным, и можно просить habanero найти информацию о
  нужных нам статьях.
  Для валидации doi используем [[http://stackoverflow.com/questions/27910/finding-a-doi-in-a-document-or-page][регулярку]]
  #+name: Дополнительные импорты
  #+BEGIN_SRC python 
    import habanero
    import re
    import bibtexparser
  #+END_SRC

  #+name: Утилиты
  #+BEGIN_SRC python
    def is_valid(s):
        return re.match(r'\s*(10[.][0-9]{3,}(?:[.][0-9]+)*/(?:(?!["&\'<>])\S)+)\b', s)
  #+END_SRC
  
  #+BEGIN_SRC python :noweb yes
    <<Дополнительные импорты>>
    from calibre.ebooks.metadata.sources.base import Source
    from calibre.ebooks.metadata.book.base import Metadata


    <<Загрузка информации>>


    <<Утилиты>>


    <<datamacro(ord=1)>>
        <<Информация о наборе>>
        <<Поля БД()>>

        def identify(self, log, result_queue, abort,
                     title=None, authors=None, identifiers={}, timeout=30):
            doi = identifiers.get("doi", None)
            if not (doi and is_valid(doi)):
                return None

            data = load_info(doi)
            if not data:
                return None
            <<Запись метаданных в БД>>
  #+END_SRC

*** Загрузка и запись метаданных
    Для начала установим соответсвия между полями в базе Calibre и
    тем, что возвращает habanero. Их спокойно можно выдумывать, и
    связывать какие поля с какими угодно.
    Так же, по этому соотвествию, можно установить список полей,
    которые затрагивает плагин ("поле... поле... поле... . Поле...")
    Их же используем для записи.
    Больше всего проблем тут доставляет разбор даты публикации,
    т.к. Calibre ожидает получить ~datetime~ объект. Мне лень сейчас
    придумывать, как нормально парсить и генерировать дату, поэтому
    месяц принимаем равным =1=, то есть =Январю=.
    #+name: Парсинг даты
    #+BEGIN_SRC elisp
      ((string-match-p "year" s)
       (format "datetime.datetime(year=data[0]['year'], month=1, day=1)"))
    #+END_SRC
    Так же автор по типу данных не совпадает: на вход Calibre
    ожидает список.
    #+name: Парсинг авторов
    #+BEGIN_SRC elisp
      ((string-match-p "author" s)
       (format "data[0]['author'].split(' and ')"))
    #+END_SRC
    Другое озадачивающее поле -- язык. Для получения корректного
    значения языка для воспользуемся встроенной функцией
    преобразования
    #+name: Дополнительные импорты
    #+BEGIN_SRC python
      from calibre.utils.localization import canonicalize_lang
    #+END_SRC
    #+name: Парсинг языка
    #+BEGIN_SRC elisp
      ((string-match-p "language" s)
       (format "canonicalize_lang(data[0]['language'])"))
    #+END_SRC
    
    Из еще оставшихся дыр - возможное отстуствие некоторых полей и
    дополнительные ключи (информация из них будет читаться в случае
    провала первого чтения).
    #+caption: Соответствия полей
    #+tblname: fields
    | Calibre   | Habanero  |
    |-----------+-----------|
    | title     | title     |
    | pubdate   | year      |
    | publisher | publisher |
    | authors   | author    |
    | language  | language  |
    #+NAME: Поля БД
    #+BEGIN_SRC python :var fields=fields[,0]
      return "touched_fields = frozenset({})".format(fields)
    #+END_SRC
    
    #+name: Поля публикации
    #+BEGIN_SRC python :var fields=fields[,0] :results code
      return "['" + "', '".join(fields) + "']"
    #+END_SRC

    #+RESULTS: Поля публикации
    #+BEGIN_SRC python
    ['title', 'pubdate', 'publisher', 'authors', 'language']
    #+END_SRC

    #+NAME: Преобразование полей
    #+BEGIN_SRC elisp :var fields=fields :noweb yes
      (defun string-translation (s)
        (cond
         <<Парсинг даты>>
         <<Парсинг авторов>>
         <<Парсинг языка>>
         ((string-match-p ", " s)
          (mapconcat (lambda (x)
                       (format "data[0]['%s']" x))
                     (split-string s ", ")
                     " + "))
         (t (format "data[0]['%s']" s))))
      (concat "result = {\n"
              (mapconcat (lambda (x)
                           (format "'%s': %s" (car x) (string-translation (cadr x))))
                         fields
                         ",\n") "}\n")
    #+END_SRC

    #+RESULTS: Преобразование полей
    : result = {
    : 'title': data[0]['title'],
    : 'pubdate': datetime.datetime(year=data[0]['year'], month=1, day=1),
    : 'publisher': data[0]['publisher'],
    : 'authors': data[0]['author'].split(' and '),
    : 'language': canonicalize_lang(data[0]['language'])}

    #+NAME: Запись метаданных в БД
    #+BEGIN_SRC python :noweb no-export
      mi = Metadata(data["title"], data["authors"])
      for attr in <<Поля публикации()>>:
          if hasattr(mi, attr) and attr in data:
              setattr(mi, attr, data[attr])

      mi.print_all_attributes()
      self.clean_downloaded_metadata(mi)
      result_queue.put(mi)
    #+END_SRC

    Теперь можно загружать данные и преобразовывать их к нужному виду.
    #+name: Загрузка информации
    #+BEGIN_SRC python :noweb no-export
      def load_info(identifier):
           data = bibtexparser.loads(habanero.content_negotiation(ids=identifier,
                                                                  format='bibtex')).entries
           <<Преобразование полей()>>
           return result
    #+END_SRC
    
** TODO Извлечение DOI из файла
